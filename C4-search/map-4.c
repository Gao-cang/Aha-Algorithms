//遍历整个地图，求岛屿个数，使用深度度优先搜索

#include<stdio.h>
#include<stdlib.h>

int a[51][51]={
    {1,2,1,0,0,0,0,0,2,3},
    {3,0,2,0,1,2,1,0,1,2},
    {4,0,1,0,1,2,3,2,0,1},
    {3,2,0,0,0,1,2,4,0,0},
    {0,0,0,0,0,0,1,5,3,0},
    {0,1,2,1,0,1,5,4,3,0},
    {0,1,2,3,1,3,6,2,1,0},
    {0,0,3,4,8,9,7,5,0,0},
    {0,0,0,3,7,8,6,0,1,2},
    {0,0,0,0,0,0,0,0,1,0},
    };
int book[51][51]={0},n=10,m=10,sum;

void dfs(int x,int y,int color){
    int next[4][4]={
        {0,1},
        {1,0},
        {0,-1},
        {-1,0}
    };
    int k,tx,ty;

    a[x][y]=color;

    for(k=0;k<=3;k++){
        //步骤二-1：计算下一点坐标
        tx=x+next[k][0];
        ty=y+next[k][1];

        //步骤二-2：判断是否越界、不循环的条件
        if(tx<0||tx>n-1||ty<0||ty>m-1){//最后一个程序发现这里与书上不同，因为我是从0开始书上从1开始
            continue;
        }

        //步骤二-3：判断符合要求的点
        if(a[tx][ty]>0 && book[tx][ty]==0){
            sum++;
            book[tx][ty]=1;
            dfs(tx,ty,color);
        }
    }
}

int main(){
    int i,j,color=0;

    for(i=0;i<n;i++){
        for(j=0;j<m;j++){
            if(a[i][j]>0){//本来是对每个点进行深度优化搜索
                color--;//但已经染色的点已经小于0了，所以避过了已经染色的岛和海洋
                book[i][j]=1;
                dfs(i,j,color);
            }
        }
    }
    
    for(i=0;i<10;i++){
        for(j=0;j<10;j++){
            printf("%3d", a[i][j]);
        }
        printf("\n");
    }

    
    system("pause");
    return 0;
}